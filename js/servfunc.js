

var servfunc = {};
var csrftoken = undefined;

$(document).ready(function () {
        
    servfunc.serverProps();  // init crlf token in case not avail
    
    // enable csrf protection on post
    function csrfSafeMethod(method) {
        // these HTTP methods do not require CSRF protection
        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
    }
    $.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!csrfSafeMethod(settings.type && !this.crossDomain)) {
                csrftoken = servfunc.getCookie('csrftoken');                
                xhr.setRequestHeader("X-CSRFToken", csrftoken);
            }
        }
    });
});


servfunc.getCookie = function(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = jQuery.trim(cookies[i]);
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}



//construct sleep time promise (time = milliseconds)
servfunc.sleep = function(time) {
  return new Promise((resolve) => setTimeout(resolve, time));
}


// from: https://gist.github.com/gordonbrander/2230317
//
//Generate unique IDs for use as pseudo-private/protected names.
//Similar in concept to
//<http://wiki.ecmascript.org/doku.php?id=strawman:names>.
//
//The goals of this function are twofold:
//
//* Provide a way to generate a string guaranteed to be unique when compared
//to other strings generated by this function.
//* Make the string complex enough that it is highly unlikely to be
//accidentally duplicated by hand (this is key if you're using `ID`
//as a private/protected name on an object).
//
//Use:
//
//  var privateName = ID();
//  var o = { 'public': 'foo' };
//  o[privateName] = 'bar';
servfunc.ID = function () {
    // Math.random should be unique because of its seeding algorithm.
    // Convert it to base 36 (numbers + letters), and grab the first 9 characters
    // after the decimal.
    return '_' + Math.random().toString(36).substr(2, 9);
};


//Function to download data to a file
// https://stackoverflow.com/a/30832210/2736453
servfunc.download = function (data, filename, type) {
    var file = new Blob([data], {type: type});
    if (window.navigator.msSaveOrOpenBlob) // IE10+
        window.navigator.msSaveOrOpenBlob(file, filename);
    else { // Others
        console.log("others download");
        var a = document.createElement("a"),
                url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        console.log("clicked?");
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            console.log("removed");
        }, 0); 
    }
    console.log("download done?");
}


// https://stackoverflow.com/a/48254637/2736453
servfunc.customStringify = function (v) {
  const cache = new Set();
  return JSON.stringify(v, function (key, value) {
    if (typeof value === 'object' && value !== null) {
      if (cache.has(value)) {
        // Circular reference found
        try {
          // If this value does not reference a parent it can be deduped
         return JSON.parse(JSON.stringify(value));
        }
        catch (err) {
          // discard key if value cannot be deduped
         return;
        }
      }
      // Store value in our set
      cache.add(value);
    }
    return value;
  });
};


servfunc.sendBlob = function(uid, blob, callback) {
    const url = `${window.location.origin}/ajax/storeblob`;
    console.log(url);
    
    let fd = new FormData();
    fd.append('uid', uid);
    fd.append('data', blob);
    $.ajax({
        type: 'POST',
        url:  url,
        data: fd, 
        processData: false,
        contentType: false,
        
    }).done( function( data ) {
        console.log(url + ' blob sent');
        callback();    
        
    }).fail( function(jqXHR, textStatus, errorThrown) { 
            alert('ajax post of blob failed! ' + textStatus + '. ' + errorThrown.replace(/\\n/g, '\n'));
    });
}


servfunc.serverProps = function() {
    // ping server using ajax to initialize a missing csrf token
    const url = `${window.location.origin}/ajax/props`;
    console.log(url);
      $.getJSON(url, function(jd) {
           console.log("Server Props: " + JSON.stringify(jd));
      })
      .fail(function(jqXHR, textStatus, errorThrown) { 
          alert('getJSON request failed! ' + textStatus + '. ' + errorThrown.replace(/\\n/g, '\n'));
      });    
}


servfunc.loadBlob = function(uid, donecb, failcb) {    
    const qry = $.param( {uid: uid} );
    const url = `${window.location.origin}/ajax/loadblob?${qry}`;
    $.ajax({                 
        url: url, 
        cache:false,
        xhr:function() { // Seems like the only way to get access to the xhr object
            var xhr = new XMLHttpRequest();
            xhr.responseType= 'blob'
            return xhr;
        }
    }).done( function( data ) {
        console.log(url + ' blob received');
        donecb( data );    
        
    }).fail( function(jqXHR, textStatus, errorThrown) { 
        failcb('ajax get of blob failed! ' + textStatus + '. ' + errorThrown.replace(/\\n/g, '\n'));
    });

}



// https://coderwall.com/p/quv2zq/deparam-function-in-javascript-opposite-of-param
servfunc.deparam = function(querystring) {
    // remove any preceding url and split
    querystring = querystring.substring(querystring.indexOf('?')+1).split('&');
    var params = {}, pair, d = decodeURIComponent, i;
    // march and parse
    for (i = querystring.length; i > 0;) {
        pair = querystring[--i].split('=');
        params[d(pair[0])] = d(pair[1]);
    }    
    return params;
}



